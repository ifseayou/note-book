### 01-kudu-tablet-design

> The implementation of tablet storage in Kudu addresses[^1] several goals:
>
> 1. Fast columnar scans In order to provide analytic performance comparable to best-of-breed[^2] immutable data formats such as Parquet and ORCFile, it’s critical that the majority of scans can be serviced from efficiently encoded columnar data files.
> 2. Low-latency random updates In order to provide fast access to update or read arbitrary rows, we require O(lg n) lookup complexity for random access.
> 3. Consistency of performance Based on our experiences supporting other data storage systems, we have found that users are willing to trade off peak performance in order to achieve predictability.
>
> In order to provide these characteristics simultaneously, Kudu does not reuse any pre-existing storage engine, but rather chooses to implement a new hybrid columnar store architecture.

kudu tablet 存储的实现解决了几个问题（目标）：

:one:  快速的列扫描为了提供可以和不可变数据格式(如Parquet，ORCFIle)可媲美的分析性能，至关重要的是，高效编码列数据文件可以服务主要的扫描。

:two: 对随机更新低延迟：随机读和随机读，提供 $O(logn)$ 的时间复杂度

:three: 表现一致性：根据我们支持其他数据存储系统的经验，我们发现很多用户原因交易峰值性能为了实现可预测性

为了同时提供这些特征，kudu 没有复用任何一种已经实现的存储引擎，而是选择实现一种新的混合列存储架构

> RowSets
>
> Tablets in Kudu are themselves subdivided into smaller units called RowSets. Some RowSets exist in memory only, termed[^4] MemRowSets, while others exist in a combination of disk and memory, termed DiskRowSets. Any given live (not deleted) row exists in exactly one RowSet; thus, RowSets form disjoint[^5] sets of rows. However, note that the primary key intervals[^6] of different RowSets may intersect. 
>
> At any point in time, a tablet has a single MemRowSet which stores all recently-inserted rows. Because these stores are entirely in-memory, a background thread periodically flushes MemRowSets to disk. The scheduling of these flushes is described in further detail in Section 4.11. 
>
> When a MemRowSet has been selected to be flushed, a new, empty MemRowSet is swapped in to replace it. The previous MemRowSet is written to disk, and becomes one or more DiskRowSets. This flush process is fully concurrent: readers can continue to access the old MemRowSet while it is being flushed, and updates and deletes of rows in the flushing MemRowSet are carefully tracked and rolled forward into the on-disk data upon completion of the flush process.

Kudu将tablets划分为更小的单元，称之为：Rowsets，有一些Rowsets仅以内存的形式存在，称之为MemRowSets；其他的Rowset以内存和磁盘想结合的形式存在，称之为：DiskRowSets。任何一行数据确定存在一个Rowset中，因此RowSets是不相交的。但是请注意，不同 RowSets的主键区间可能相交。

在任何时间点，一个tablet只有一个MemRowSet 用来存储所有最近插入的行，因为这些存储完全在内存中，一个后台线程会定期的将内存中的书刷写到磁盘中，关于刷写的调度的问题在4.11部分(我们这里暂时不做翻译)。

当一个MemRowSet被标记为即将刷写到磁盘的时候，一个新的MemRowSet会生成去替换老的MemRowSet。上一个MemRowSet 刷写到磁盘会变成DisRowSet。刷写进程是并发的，老的MemRowSet 被刷写时候，仍然可以提供读服务，刷写时删除和更新操作也会被记录到磁盘上，并且最终合并到DiskRowSet。







[^1]: addresses : 解决
[^2]: breed: 品种
[^3]:arbitrary ： 随意
[^4]: terms: 条款； term:术语； termed : 称为
[^5 ]: disjoint ：不相交的，joint : 联合的
[^6]: interval: 间隔，这里和primary key在一起，译为：主键区间







